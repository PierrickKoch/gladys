#!/usr/bin/env python

import time
import struct
import colorsys

try:
    from PySide import QtCore, QtGui
except ImportError:
    print("[error] sudo apt-get install python-pyside")
    import sys; sys.exit(1)

try:
    import gladys
except ImportError:
    print("[error] install gladys [and setup PYTHONPATH]")
    import sys; sys.exit(1)

class ImageLabel(QtGui.QLabel):
    def __init__(self):
        QtGui.QLabel.__init__(self)
        self.path = QtGui.QPolygonF()
    def set_image(self, image):
        self.setPixmap(QtGui.QPixmap.fromImage(image))
    def paint_path(self, path):
        self.path = QtGui.QPolygonF()
        for x, y in path:
            self.path.append(QtCore.QPointF(x, y))
        self.repaint()
    def paint_all_path(self, path):
        self.path = QtGui.QPolygonF()
        for f in path:
            for x, y in f:
                self.path.append(QtCore.QPointF(x, y))
        self.repaint()
    def paintEvent(self, event):
        QtGui.QLabel.paintEvent(self, event)
        painter = QtGui.QPainter(self)
        #painter.setPen(QtGui.QPen(QtCore.Qt.black, 2))
        painter.setPen(QtGui.QPen(QtCore.Qt.yellow, 2))
        painter.drawPoints(self.path)

def get_bgra32(b=0,g=0,r=0,a=0):
    return struct.pack('4B', int(b*255), int(g*255), int(r*255), int(a*255))

def float_to_rgb(hue):
    assert(0.0 <= hue <= 1.0)
    # from blue to red (instead of red to red)
    # aka from 240 to 0 instead of 0 to 360 degrees (HSV)
    hue = (1 - hue) / 1.5
    return colorsys.hsv_to_rgb(hue, 1, 1)

def float_to_bgra32(hue):
    r, g, b = float_to_rgb(hue)
    return get_bgra32(b,g,r,1)

class MainWindow(QtGui.QMainWindow):
    def __init__(self, argv):
        super(MainWindow, self).__init__()
        self.ng = self.start = self.end = None
        # frontier exploration
        self.fX = self.fL = None
        self.toggleF = False        # Don't display by default

        # image viewer
        self.image_label = ImageLabel()
        self.setCentralWidget(self.image_label)

        self.setWindowTitle("Gladysplay")
        self.resize(200, 200)

        self.fregion = argv[1]
        self.frobot = argv[2]

        print("===============================\n"
              "  Welcome to Gladys display !\n"
              "===============================\n\n"
              "Actions\n"
              "-------\n"
              " - Click     = select start and end points\n"
              " - Space     = start search path\n"
              " - C         = clear start and end points\n"
              " - N         = switch {region,weight} view\n"
              " - F         = compute frontiers for exploration\n"
              " - H         = toggle frontiers display\n"
              " - Escape    = quit\n")

        # key bindings
        self._bindings = {}
        self.bind(QtCore.Qt.Key_Escape, self.close)
        self.bind(QtCore.Qt.Key_Space,  self.start_search)
        self.bind(QtCore.Qt.Key_C,      self.clear_points)
        self.bind(QtCore.Qt.Key_N,      self.switch_raster)
        self.bind(QtCore.Qt.Key_F,      self.start_frontiers_computation)
        self.bind(QtCore.Qt.Key_H,      self.toggle_frontiers)

        self._raster = ""
        self._images = {}
        self._region = None
        self._weight = None
        print("Loading graph...")
        # start to load the graph in 50ms
        QtCore.QTimer.singleShot(50, self.load_nav_graph)
        print("Loading frontier module...")
        # start to load the module in 50ms
        QtCore.QTimer.singleShot(50, self.load_frontiers)

    def i8u2rgb(self, width, height, data8u):
        """ Convert a grayscale image to RGB """
        buff = b''.join([float_to_bgra32(hue / 255.0) for hue in data8u])
        image = QtGui.QImage(buff, width, height, QtGui.QImage.Format_ARGB32)
        # image needs to be copied since it does not seems to hold the buffer
        return image.copy()

    def show_region(self):
        if not self._region:
            t_start = time.time()
            self._region_map = self._weight.get_region()
            self._region = self._region_map.get_bands_as_uchar()
            print("Got the region bands (%.3fs)" \
                % (time.time() - t_start) )
        names = self._region.keys()
        if self._raster not in names:
            self._raster = names[0]
        else:
            index = names.index(self._raster) + 1
            if index < len(self._raster):
                self._raster = names[index]
            else:
                return -1
        t_start = time.time()
        if self._raster not in self._images:
            self._images[self._raster] = self.i8u2rgb(
                    self._region_map.get_width(),
                    self._region_map.get_height(),
                    self._region[self._raster] )
        if not self._images[self._raster]:
            print("%s region band is null, skip it."%self._raster)
            return self.show_region()
        self.image_label.set_image( self._images[self._raster] )
        print("Display the %s region band (%.3fs)" \
            % (self._raster, time.time() - t_start) )

    def show_weight(self):
        t_start = time.time()
        if 'weight' not in self._images:
            self._weight = self.ng.get_map()
            band = self._weight.get_weight_band_uchar()
            self._images['weight'] = self.i8u2rgb(self._weight.get_width(),
                self._weight.get_height(), band)
        self.image_label.set_image( self._images['weight'] )
        print("Display the weight map (%.3fs)" % (time.time() - t_start) )

    def switch_raster(self):
        if not self._weight or self.show_region() == -1:
            self.show_weight()
            self._raster = ""

    def load_nav_graph(self):
        t_start = time.time()
        self.ng = gladys.nav_graph(self.fregion, self.frobot)
        print("Graph loaded (%.3fs)" % (time.time() - t_start) )
        self.switch_raster()

    def load_frontiers(self):
        t_start = time.time()
        self.fX = gladys.fExploration(self.fregion, self.frobot)
        #TODO Do not duplicate the weight_map ! (re-use self.ng)
        print("Frontier_Exploration loaded (%.3fs)" % (time.time() - t_start) )
        self.switch_raster()


    def update_path(self, path):
        self.image_label.paint_path(path)

    def search(self):
        if not self.ng:
            print("[error] not ready for search (no graph)")
            return

        print("Search a path between %s" % str([self.start, self.end]) )
        t_start = time.time()
        pp = self.ng.search(self.start, self.end)
        print("Got a path of %i points (%.3fs)" % ( len(pp), \
            (time.time() - t_start) ) )
        self.update_path(pp)
        self.start = self.end = None

    def compute_frontiers(self):
        if not self.fX:
            print("[error] not ready to compute frontiers: no frontier module :-( ")
            return

        print("Computing frontiers for exploration from the seed %s" % str(self.start) )
        t_start = time.time()
        self.fL = self.fX.compute_frontiers(self.start) # use the default algorithm
        print("Got %i frontiers (%.3fs)" % ( len(self.fL), \
            (time.time() - t_start) ) )
        # Display
        self.toggleF = False # to force toggle behaviour into display mode
        self.toggle_frontiers()
        self.start = self.end = None

    def toggle_frontiers(self):
        if self.toggleF:
        # already display -> hide
            self.toggleF = False
            self.show_region()
        else:
        # hidden -> display
            self.toggleF = True
            self.show_region()
            self.image_label.paint_all_path(self.fL)

    def bind(self, key, func):
        self._bindings[key] = func

    def start_search(self):
        if self.start and self.end:
            # start search in 50ms
            QtCore.QTimer.singleShot(50, self.search)
        else:
            print("select start and end points")

    def start_frontiers_computation(self):
        if self.start :
            # start search in 50ms
            QtCore.QTimer.singleShot(50, self.compute_frontiers)
        else:
            print("Please select start point")

    def clear_points(self):
        self.start = self.end = None
        print("clear start and end")

    # PySide.QtGui.QWidget.keyPressEvent(event)
    def keyPressEvent(self, event):
        if event.key() in self._bindings:
            self._bindings[event.key()]()

    # PySide.QtGui.QWidget.mousePressEvent(event)
    def mousePressEvent(self, event):
        pose = event.pos()
        if not self.start:
            self.start = ( pose.x(), pose.y() )
            print("start = %s" % str(self.start) )
        if not self.end:
            self.end = ( pose.x(), pose.y() )
            if self.end == self.start:
                self.end = None
            else:
                print("end = %s" % str(self.end) )

def main(argv=[]):
    if len(argv) < 3:
        print("usage: %s region.tif robot.json"%argv[0])
        return 1
    app = QtGui.QApplication(argv)
    mww = MainWindow(argv)
    mww.show()
    return app.exec_()

if __name__ == '__main__':
    import sys
    sys.exit( main(sys.argv) )

